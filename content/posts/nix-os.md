+++
title = 'Nix Os'
date = 2024-07-05T16:51:38+03:00
+++

[Nix](https://nixos.org/) - это в первую очередь пакетный менеджер, концепция которого строится вокруг декларативного подхода к управлению пакетами.
*кому интересна теория, можно почитать [здесь](https://web.archive.org/web/20190421081837/https://nixos.org/~eelco/pubs/iscsd-scm11-final.pdf)*.
На текущий момент репозиторий языка занимает первое место по количеству доступных пакетов, обогнав даже знаменитый AUR.

[![Сравнение пакетов](https://discourse.nixos.org/uploads/default/original/2X/1/1f6a38cffbc0072e4c3392447e5a83176b3bc964.png)](https://discourse.nixos.org/t/nixpkgs-has-been-the-largest-repository-for-months/10667)

Также это полноценный, чистый функциональный язык программирования, который создан для управления конфигурацией пакетов nix.
И, наконец, `NisOS` - это Linux-дистрибутив, который создан на базе пакетного менеджера `Nix`. 

Последнее время в IT-сфере много шуба вокруг NixOS, некоторые даже называют его новым **Arch Linux** (из того же факта, что это Linux для элитариев).
Для меня это уже третья попытка использования NixOS в качестве своей домашней системы (и пока самая успешная).

На очередную попытку попробовать меня вдохновило видео:

{{< youtube CwfKlX3rA6E >}}

И нужно сказать, что это та еще карусель эмоций.

Рассмотрим сначала, за что любят этот дистрибутив:

- Неизменяемая read-only система.
Единственный способ управления системой - это `nix`. Каждое обновление "накладывается" поверх предыдущего.
- Неограниченное количество бэкапов системы.
Если обновляется библиотека, NixOS сохранит обе версии, и будет хранить старые версии до тех пор, пока мы не воспользуемся garbage collector'ом.
В любой момент пользователь может вернуться в предыдущей сохраненной конфигурации системы без сложностей.
В результате мы получаем систему, которую крайне сложно сломать, любая наша ошибка легко исправляется откатом назад. 
Это, кстати, сильно облегчает обучение.
- Отсутствие dependency hell: `nix` без проблем использует несколько версий библиотек для каждого конкретного случая.
- Огромное количество доступного софта, причём свежего, в отличии, например, от репозиториев Debian.
- Конфигурация практически ВСЕГО (от партицирования диска до настроек текстового редактора) одним едиственным спобобом - посредством 
файлов *.nix.

Но, увы, не всё так идеально и гладко:

- Официальная документация не всегда полна и понятна, конкретную информацию часто нужно искать по блогам и Youtube видео.
При этом информация устаревает относительно быстро, посты старше нескольких лет уже не слишком актуальны.
- Высокий порог вхождения: в сочетании с предыдущим пунктом, можно потратить многие часы в попытах разобраться с тем, что
на любом другом дистрибутиве заняло бы минуты.
Тут сильно поможет, если имеется какой-никакой опыт с функциональными языками вроде `Haskell` или `OCaml`.
- Огромное множество "фич", которые приняты и признаны сообществом, но все еще официально не поддерживаются (вроде [Flakes](https://nixos.wiki/wiki/Flakes), которые
я настоятельно рекомендую использовать сразу, если решите попробовать `NixOS`, и [Home Manager](https://nixos.wiki/wiki/Home_Manager)).
При этом не существует какого-то общепризнанного подхода или гайдлайна. Для решения одной проблемы может быть множество подходов, которые приводят к схожему результату,
что, я считаю, большой недостаток.
- Работа с ошибками: стактрейсы одни из самых ужасных, с которыми я сталкивался, в лучшем случае указывают место в конфиге, которое является
причиной ошибки, в худшем там не будет вообще ничего связанного в вашим конфигом, удачи разобраться!
Желательно иметь хотя бы общее представление о `nix` как языке, чтобы понимать некоторые особенности конфигурирования, вроде `let in`.

Когда всё в `NixOS` просто работает, это работает отменно.
Но когда у что-то не работает, то это реально больно, и время, которое ты тратишь на решение проблемы часто на порядок больше, чем на других системах.

## Выводы

На данный момент я всё еще не уверен, насколько резонно использовать NixOS в качествое своей домашней системы.
Надежности системы можно добиться и другими способами (существуют, например, другие "неизменяемые" дистрибутивы, вроде [Fedora Silverblue](https://fedoraproject.org/atomic-desktops/silverblue/)).
Полная конфигурация системы одним единственным подходом -- задача непростая и времязатратная, а результат не всегда идеален.
Мне сильно помогло установка на то, что не всё должно быть идеально настроено только в соответсвии с nix-подходом.
Всегда можно грызть слона по кусочкам, начиная с более примитивного подхода, и постепенно приводить его в соответствие с философией `nix`.
Большой потеницал для использования как DevOps инструмента: представьте себе -- устанавливаем 
на десятки компьютеров пользователей (можно даже с разным хадром) абсолютно идентичные преднастроенные пакеты программ
и все это на условно "неубиваймой" для пользователя системе.

(у `nix` также есть и другие использования -- например создание виртуального окружения для работы с языками программирования).

