+++
title = 'Делаем OOP менее неуклюжим'
date = 2024-05-23T23:09:49+03:00
draft = true
+++


На настоящий день наиболее популярным стилем программирования на `Python` будет являться ООП.
И это несмотря на то, что язык является мультипарадигмальным и поддерживает множество подходов к написанию программ.
Так, например, достаточно много средств стандартной библиотеке позволяют писать на `Python` в вполне вполне функциональном стиле.
И также в последнее время есть множество 

Допустим, мы имеем класс, который расчитывает данные по наиболее близким по расстоянию строкам. Один из методов этого класса сохраняет результат в DataFrame (библиотека pandas). Если подумать, этот метод противоречит принципу SRP, так как сохранение результата в какой-то формат это уже отдельная задача и потенциально этих форматов может быть множество. Кроме того, можно рассмотреть ситуацию, когда нам дальше нужно использовать этот результат и сохранить его в файл. Для этого как раз хоршо подойдет функциональная композиция.

```python
class LSC(DataHandler):
    ...

    def to_dataframe(self):
        df = pd.DataFrame({
            'client_sku': self.client_sku,
            'base_sku': self.base_sku,
            'common_string': self.common_string
        })
        res_grp = df.groupby('client_sku', as_index=False).agg({'common_string': self.max_len_str})
        res = res_grp.merge(df, how='inner', on=['client_sku', 'common_string'])
        return res
````

Преобразуем в:

```python
def datahander_res_to_dataframe(dh: DataHander) -> pd.DataFrame:
    df = pd.DataFrame({
        'client_sku'   : dh.client_sku,
        'base_sku'     : dh.base_sku,
        'common_string': dh.common_string
    })
    res_grp = df.groupby('client_sku', as_index=False).agg({'common_string': dh.max_len_str})
    res = res_grp.merge(df, how='inner', on=['client_sku', 'common_string'])
    return res

def dataframe_to_csv(path: str, df: pd.DataFrame) -> None:
    df.to_csv(path)

"""
Пример вызова
"""

dataframe_to_csv(
    "res.csv",
    datahander_res_to_dataframe(lsc_handler),
)
```

Общая идея заключается в том, что мы выносим части логики раобты программы:

- которые автономны от остальных частей класса
- могут меняться часто

в отдельные функции, которые легко "состыковать" друг с другом - 
т.е. применить функциональную композицию функции.

- избегаем прегруженности класса методами, напрямую не относящимся к его обязанностям (соблюдаем SRP)
- делаем зависимости более простыми, читаемыми и понятными
- явно выражаем логику действий.

Описанный подход позволяет сократить значительно объём кода, 
сделав операции, которые не совсем укладываются в SRP основного класса,
не создавая при этом большие нагромождения иерархий новых классов.

В большинстве случаев это имеет куда больший смысл, 
когда предполагаемые действия достаточно просты и не подразумевают больших вариаций.

Кроме того, таким образом код выглядит гораздо читабельнее, 
ведь композиция из 2-3 функций довольно легко воспринимается, 
в отличие от случая, когда мы используем несколько классов в составе композиции другого класса.

В целом, этот подход наверное более "ленивый", чем корректная композиция из нужных классов, 
однако если нам нужно всего лишь добавить некоторые несложные операции, 
которые не входят в обязанности класса, мы выигрываем значитльно в простоте и читаемости итоговой программы.
